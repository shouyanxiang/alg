# 析构函数先拿到锁【用户退房最先发生】
分析init、get_model、call_back三个接口所有可能的行为:

先分析init、get_model
如果init、get_model这两个接口还未被调用，则会因为if(android_model_downloader_pointer) 【指针判空】返回false而不去执行
如果init、get_model已经在执行中，在先执行完析构函数之后，AndroidModelDownloader实例会等init、get_model执行结束后完成最终释放，init执行速度本身很快，get_model执行中发现exist_flag_=false会直接退出，不会继续轮询等待模型下载回调，因此这种情况下，init、get_model接口不会导致退房时卡住

对于callback()
由于这个接口会异步的被JAVA层模型下载回调函数调用，因此callback()执行过程中，AndroidModelDownloader实例可能已经被销毁
分两种情况：
1. callback()拿到mutex时，AndroidModelDownloader实例还未被销毁，此时`android_model_downloader_pointer_set.count(cpp_model_downloader_poiner)`不为0，因此正常执行回调
2. callback()拿到mutex时，AndroidModelDownloader实例已经被完全销毁，此时`android_model_downloader_pointer_set.count(cpp_model_downloader_poiner)`为0，直接退出即可，不会存在访问到野指针风险


# 析构函数后拿到锁
init、get_model、call_back三个接口顺利执行后，再析构，程序正常退出
